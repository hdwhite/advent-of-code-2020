These are my programs for Advent of Code 2020 (https://adventofcode.com/2020). I used Python since I felt like I needed a refresher in that language. Since these were designed to be done quickly and efficiently, I didn't spend a lot of time optimising or prettifying my code or making sure my variable names made sense. Here are some quick personal thoughts about each day's challenge and what I would have done differently had I intended to make the code actually maintainable:

- Day 1: Part 1 was done by sorting the list and working from both ends trying to find the exact total. Its efficiently is that of the sorting done (as scanning the list is O(n)). Part 2 in retrospect could have been done by looping through each value and then using part 1's solution, though the answer I used does a decent job of not checking unnecessary cases. (Of course, it could probably be easily refactored into a series of for loops for readability.)
- Day 2: This was solved fairly easily using regex. Not a whole lot to say here.
- Day 3: My answer for part 1 was very quick, though my laziness and usage of magic numbers made part 2 not as trivial as it could have been.
- Day 4: I wanted to easily check to see which criteria evaluations were or were not working correctly, so I opted to have the validation code be a number from 0-128. I probably could have used regex more for part 2, though I'm not really a fan of using it to validate numerical ranges as it's much more annoying if you have to change the values.
- Day 5: This one wasn't that hard with bitshifting, and thankfully my solution for part 1 made it easy to extend to part 2. That one could be done in O(n) instead of O(n log n), though in the case of a 1024-seat plane that optimisation wasn't really that necessary.
- Day 6: This one was basically going through each line and either oring or anding each line depending on which part it was.
- Day 7: I used a basic recursion function for this day's problems. I could have implemented a dictionary to store the results so the program wouldn't have to look up the contents of "mirrored indigo bags" yet again, though the input wasn't nearly large enough and the algorithm not complicated enough for it to make too much of a difference.
- Day 8: In part 2 I went through each line and flipped the instruction to see if it would have solved the challenge. If the input were longer, I definitely would have had to had to go through the inital run, find each line it visited, and only flip those instructions.
- Day 9: I'm sure there's probably a quicker algorithm for finding the answer to part 2, though the fact that the list of numbers was not monotonically increasing made it significantly less trivial. (And again, the program ran instantly.)
- Day 10: If there were a gap between two consecutive adaptors of 3 jolts, both of them had to be used. That way, I could reduce the problem to a bunch of smaller ones that I could recursively search through and multiply the results to get a final answer.
- Day 11: I wanted to try to fiddle with lambda functions in part 1, which was not optimal, but I decided to go for practice over optimisation for this one. Anyway, I'm sure variant of the Game of Life will never show up again.
- Day 12: The tricky bit with this one was handling rotations, though every instruction being in increments of 90 degrees meant I only had to deal with (x, y) being mapped to (-y, x) and vice versa.
- Day 13: Part 1 was fairly simple with modular division. For part 2 I spend a lot of time trying to find a mathematical formula for the solution, but knowing the bus numbers were relatively prime meant I could use the fact that if x were a valid answer for busses x, y, and z, then the final answer had to be of the form n\*(x\*y\*z)+x for some natural number n.
- Day 14: Lots of bitshifts. This one probably wouldn't have worked too well had there been lots of floating bits in the bitmask, though I think that would have caused issues with calculating the final solution regardless.
- Day 15: This was an exercise in optimisation. In part 1 I used the default implemention of a list, while in part 2 I switched to a dictionary of each number and when it was last spoken. That way I wouldn't have to repeatedly walk back through the list.
- Day 16: Most of this day's work was in parsing the input. I cheated a bit knowing that each field had two ranges of values, though it wouldn't be too hard to implement a more general solution, I'd suspect. The second part involved repeatedly finding a field that had to match a value, and eliminating that value from all other fields until a unique solution is found.
- Day 17: This was another Game of Life implementation. Since the grid was infinite, I stored a map of each point that was "on" rather than trying to store the grid in its entirety.
- Day 18: In part 1, I just iterated through the expression, potentially recursing through any parentheticals as they came up. For part 2, I did it the more "proper" way and parsed it in postfix notation, swapping the precedence of the + and * operators.
- Day 19: For this one, I recursively went down through the rules with the input string. This allowed me to skip over the second part of any rule which mismatched the string in the first part. This also happened to make part 2 work farily well, since the self-referential rules would have to stop once the end of the string is reached.
- Day 20: This was probably the most difficult puzzle of the entire set. Finding corners and edges weren't too hard, since I could store the numerical values of each edge and see if they matched any other edge, possibly with the bits reversed. Stitching the tiles together took a lot of work, since I had to implement a Tile class, add support for flipping and rotating, and essentially brute force my way from corner to corner finding matches. Finding sea monsters weren't too hard, especially since there was only one orientation that featured them.
- Day 21: If a food contains a certain allergen, all of the ingredients that aren't in that food cannot contain said allergen. Using that, it was fairly easy to eliminate possibilities, and then I could use something similar to Day 16 to deduce which ingredient contained which allergen.
- Day 22: Part 1 was simple compared to previous puzzles. Part 2 was similar, except with some recursion thrown in. I probably could have been a bit more elegant in terms of checking the game state for any repeats, though it worked well enough with a 50-card deck.
- Day 23: For part 2, I created a doubly linked list with some optimisations for the specific problem at hand. It probably could have been done more optimally, but I was able to get the solution for a million inputs and 10 million moves within 45 seconds.
- Day 24: Part 1 was just using coordinates for hexagonal tiles, in which I had the axes be e-w and ne-sw. The second part was once again Game of Life (but hexagonally), so it didn't require a ton of extra work other than making sure I had the adjacencies correct.
- Day 25: The final problem was not too hard, since it basically involved a bunch of modular multiplication.

Overall, I had a lot of fun with this, and it gave me a lot of practice working with Python. A lot of the later problems did provide a non-trivial challenge, and several of these gave me cause to consider how to solve the problem quickly and elegantly and not just how to put down the first answer that comes to mind but would be too slow.